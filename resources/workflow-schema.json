{
  "schemaVersion": "1.0.0",
  "metadata": {
    "description": "Workflow schema for CC Workflow Studio",
    "maxNodes": 50,
    "supportedNodeTypes": [
      "start",
      "end",
      "prompt",
      "subAgent",
      "askUserQuestion",
      "ifElse",
      "switch",
      "skill",
      "mcp",
      "subAgentFlow",
      "codex"
    ]
  },
  "nodeTypes": {
    "start": {
      "description": "Workflow entry point. Exactly one required per workflow.",
      "fields": {
        "label": { "type": "string", "required": false, "default": "Start" }
      },
      "inputPorts": 0,
      "outputPorts": 1
    },
    "end": {
      "description": "Workflow exit point. At least one required per workflow.",
      "fields": {
        "label": { "type": "string", "required": false, "default": "End" }
      },
      "inputPorts": "unlimited",
      "outputPorts": 0
    },
    "prompt": {
      "description": "Display a message/instructions to user",
      "fields": {
        "label": { "type": "string", "required": false },
        "prompt": { "type": "string", "required": true, "maxLength": 10000 },
        "variables": { "type": "object", "required": false }
      },
      "inputPorts": 1,
      "outputPorts": 1
    },
    "subAgent": {
      "description": "AI sub-agent executing a task with given prompt",
      "fields": {
        "description": { "type": "string", "required": true, "maxLength": 200 },
        "prompt": { "type": "string", "required": true, "maxLength": 10000 },
        "tools": { "type": "string", "required": false },
        "model": {
          "type": "string",
          "required": false,
          "enum": ["sonnet", "opus", "haiku", "inherit"],
          "default": "sonnet"
        },
        "color": {
          "type": "string",
          "required": false,
          "enum": ["red", "blue", "green", "yellow", "purple", "orange", "pink", "cyan"],
          "description": "Visual indicator color for this sub-agent (optional)"
        },
        "memory": {
          "type": "string",
          "required": false,
          "enum": ["user", "project", "local"],
          "description": "Persistent memory scope. 'user'=cross-project, 'project'=VCS-trackable, 'local'=local-only"
        },
        "outputPorts": { "type": "number", "required": true, "value": 1 }
      },
      "inputPorts": 1,
      "outputPorts": 1
    },
    "askUserQuestion": {
      "description": "Present a question with multiple-choice options",
      "fields": {
        "questionText": { "type": "string", "required": true, "maxLength": 500 },
        "options": {
          "type": "array",
          "required": true,
          "minLength": 2,
          "maxLength": 4,
          "items": {
            "id": { "type": "string", "required": false },
            "label": { "type": "string", "required": true, "maxLength": 50 },
            "description": { "type": "string", "required": true, "maxLength": 200 }
          }
        },
        "multiSelect": { "type": "boolean", "required": false, "default": false },
        "useAiSuggestions": { "type": "boolean", "required": false, "default": false },
        "outputPorts": { "type": "number", "required": true, "min": 1, "max": 4 }
      },
      "inputPorts": 1,
      "outputPorts": "2-4"
    },
    "ifElse": {
      "description": "Two-way conditional branching (if/else). Use for 2-way branching only (true/false).",
      "fields": {
        "evaluationTarget": { "type": "string", "required": false },
        "branches": {
          "type": "array",
          "required": true,
          "length": 2,
          "items": {
            "id": { "type": "string", "required": false },
            "label": { "type": "string", "required": true, "maxLength": 50 },
            "condition": { "type": "string", "required": true, "maxLength": 500 }
          }
        },
        "outputPorts": { "type": "number", "required": true, "value": 2 }
      },
      "inputPorts": 1,
      "outputPorts": 2
    },
    "switch": {
      "description": "Multi-way branching (switch/case). Use for 3+ way branching - ideal for time-based, case-based, or multi-condition routing. **Important: Always include a default branch as the last branch with isDefault: true.**",
      "fields": {
        "evaluationTarget": { "type": "string", "required": false },
        "branches": {
          "type": "array",
          "required": true,
          "minLength": 2,
          "maxLength": 10,
          "items": {
            "id": { "type": "string", "required": false },
            "label": { "type": "string", "required": true, "maxLength": 50 },
            "condition": { "type": "string", "required": true, "maxLength": 500 },
            "isDefault": {
              "type": "boolean",
              "required": false,
              "default": false,
              "description": "If true, this is the default branch (must be last, exactly one per node)"
            }
          },
          "constraint": "Last branch must have isDefault: true with label 'default' and condition 'Other cases'"
        },
        "outputPorts": { "type": "number", "required": true, "min": 2, "max": 10 }
      },
      "inputPorts": 1,
      "outputPorts": "2-10"
    },
    "skill": {
      "description": "Reference a Claude Code Skill (specialized agent capability defined in SKILL.md files). ONLY use Skills that are available on the system - do NOT fabricate Skills. If no matching Skill exists, use a prompt or subAgent node instead. **Important: Skills always have exactly 1 output port. For conditional branching based on Skill results, add an ifElse or switch node after the Skill node.**",
      "fields": {
        "name": {
          "type": "string",
          "required": true,
          "maxLength": 64,
          "pattern": "^[a-z0-9-]+$",
          "description": "Exact Skill name from available Skills list"
        },
        "description": {
          "type": "string",
          "required": true,
          "maxLength": 1024,
          "description": "Exact description from available Skills list"
        },
        "scope": {
          "type": "string",
          "enum": ["user", "project", "local"],
          "required": true,
          "description": "Skill scope: user (all projects), project (this project, shared), local (this project, private)"
        },
        "skillPath": {
          "type": "string",
          "required": false,
          "description": "Auto-resolved by system after generation - do NOT include in AI output"
        },
        "allowedTools": {
          "type": "string",
          "required": false,
          "description": "Optional tool restrictions from Skill definition"
        },
        "validationStatus": {
          "type": "string",
          "enum": ["valid", "missing", "invalid"],
          "required": true,
          "default": "valid"
        },
        "executionMode": {
          "type": "string",
          "enum": ["load", "execute"],
          "required": false,
          "default": "execute",
          "description": "Execution mode: 'execute' runs the Skill (default), 'load' loads the Skill as knowledge context without executing it"
        },
        "executionPrompt": {
          "type": "string",
          "required": false,
          "maxLength": 2000,
          "description": "Custom execution instructions when executionMode is 'execute'. Ignored when executionMode is 'load'."
        },
        "outputPorts": {
          "type": "number",
          "required": true,
          "value": 1
        }
      },
      "inputPorts": 1,
      "outputPorts": 1
    },
    "mcp": {
      "description": "Execute an MCP (Model Context Protocol) tool from an external server. MCP enables integration with external services, databases, APIs, and tools. In 'aiParameterConfig' mode, select a server and tool, then provide a natural language description of the parameters for AI to configure automatically.",
      "fields": {
        "serverId": {
          "type": "string",
          "required": true,
          "minLength": 1,
          "maxLength": 100,
          "description": "MCP server identifier (e.g., 'playwright', 'github', 'filesystem')"
        },
        "toolName": {
          "type": "string",
          "required": false,
          "minLength": 0,
          "maxLength": 100,
          "description": "Tool function name from the MCP server. Required for manualParameterConfig/aiParameterConfig; optional in aiToolSelection mode"
        },
        "toolDescription": {
          "type": "string",
          "required": false,
          "maxLength": 1024,
          "description": "Human-readable description of what the tool does"
        },
        "parameters": {
          "type": "array",
          "required": false,
          "description": "Array of parameter schema definitions (NOT parameter values). Each parameter object must have: name (string), type (string), description (string), required (boolean). Example: [{\"name\": \"url\", \"type\": \"string\", \"description\": \"Target URL\", \"required\": true}]",
          "items": {
            "name": { "type": "string", "required": true },
            "type": {
              "type": "string",
              "required": true,
              "enum": ["string", "number", "boolean", "array", "object"]
            },
            "description": { "type": "string", "required": false },
            "required": { "type": "boolean", "required": true }
          }
        },
        "parameterValues": {
          "type": "object",
          "required": false,
          "description": "Key-value pairs of parameter values. Keys must match parameter names from the 'parameters' array. Example: {\"url\": \"https://example.com\"}"
        },
        "mode": {
          "type": "string",
          "required": false,
          "enum": ["manualParameterConfig", "aiParameterConfig", "aiToolSelection"],
          "default": "aiParameterConfig",
          "description": "Configuration mode. 'aiParameterConfig' is recommended for AI-generated workflows. Required fields per mode: (1) manualParameterConfig: serverId, toolName, toolDescription, parameters (empty [] OK), parameterValues (if parameters non-empty), validationStatus, outputPorts=1. (2) aiParameterConfig: serverId, toolName, toolDescription, parameters (min 1 item), aiParameterConfig.description (non-empty), validationStatus, outputPorts=1. (3) aiToolSelection: serverId, aiToolSelectionConfig.taskDescription (non-empty), validationStatus, outputPorts=1."
        },
        "aiToolSelectionConfig": {
          "type": "object",
          "required": false,
          "description": "Required when mode is 'aiToolSelection'. Contains the task description for AI-driven tool selection.",
          "properties": {
            "taskDescription": {
              "type": "string",
              "required": true,
              "minLength": 1,
              "description": "Natural language description of the task to accomplish"
            },
            "timestamp": {
              "type": "string",
              "required": false,
              "description": "ISO 8601 timestamp of when this configuration was created"
            }
          }
        },
        "aiParameterConfig": {
          "type": "object",
          "required": false,
          "description": "Required when mode is 'aiParameterConfig'. Contains a natural language description for AI to configure parameter values.",
          "properties": {
            "description": {
              "type": "string",
              "required": true,
              "minLength": 1,
              "description": "Natural language description of desired parameter values. NOT 'taskDescription' — use 'description' for this field."
            },
            "timestamp": {
              "type": "string",
              "required": false,
              "description": "ISO 8601 timestamp of when this configuration was created"
            }
          }
        },
        "validationStatus": {
          "type": "string",
          "enum": ["valid", "missing", "invalid"],
          "required": true,
          "default": "valid"
        },
        "outputPorts": {
          "type": "number",
          "required": true,
          "value": 1
        }
      },
      "inputPorts": 1,
      "outputPorts": 1,
      "aiGenerationGuidance": {
        "mode": "Use 'aiParameterConfig' mode. Provide serverId, toolName, toolDescription, parameters (min 1 item), and aiParameterConfig.description",
        "parameters": "Array of parameter schema objects with {name, type, description, required} fields. In aiParameterConfig mode, must have at least 1 item. In manualParameterConfig, empty [] OK. In aiToolSelection, optional.",
        "parameterValues": "Optional object with key-value pairs matching parameter names",
        "requiredFieldsPerMode": {
          "aiParameterConfig": {
            "required": [
              "serverId",
              "toolName",
              "toolDescription",
              "parameters",
              "aiParameterConfig",
              "validationStatus",
              "outputPorts"
            ],
            "notes": "parameters must have at least 1 item; aiParameterConfig.description must be non-empty; parameterValues is optional"
          },
          "manualParameterConfig": {
            "required": [
              "serverId",
              "toolName",
              "toolDescription",
              "parameters",
              "validationStatus",
              "outputPorts"
            ],
            "conditionallyRequired": {
              "parameterValues": "required when parameters array is non-empty"
            },
            "notes": "parameters can be empty [] for tools with no parameters"
          },
          "aiToolSelection": {
            "required": ["serverId", "aiToolSelectionConfig", "validationStatus", "outputPorts"],
            "notes": "aiToolSelectionConfig.taskDescription must be non-empty; toolName/toolDescription/parameters are optional"
          }
        },
        "commonTools": {
          "playwright": [
            "playwright_navigate",
            "playwright_click",
            "playwright_screenshot",
            "playwright_evaluate"
          ],
          "filesystem": ["read_file", "write_file", "list_directory"],
          "github": ["get_issue", "create_pull_request", "list_repositories"]
        },
        "example": {
          "type": "mcp",
          "data": {
            "serverId": "playwright",
            "toolName": "playwright_navigate",
            "toolDescription": "Navigate to a URL in the browser",
            "parameters": [
              {
                "name": "url",
                "type": "string",
                "description": "The URL to navigate to",
                "required": true
              }
            ],
            "parameterValues": {},
            "mode": "aiParameterConfig",
            "aiParameterConfig": {
              "description": "Navigate to example.com and take a screenshot of the page",
              "timestamp": "2025-02-28T00:00:00Z"
            },
            "validationStatus": "valid",
            "outputPorts": 1
          }
        }
      }
    },
    "subAgentFlow": {
      "description": "Execute a defined sub-agent flow. Use this to reference and run a sub-agent flow within the main workflow. **Important: Always has exactly 1 output port. Sub-agent flows are executed sequentially from their Start to End node.**",
      "fields": {
        "subAgentFlowId": {
          "type": "string",
          "required": true,
          "description": "ID of the sub-agent flow to execute (must match an existing sub-agent flow in the workflow's subAgentFlows array)"
        },
        "label": {
          "type": "string",
          "required": true,
          "maxLength": 50,
          "description": "Display label for this node"
        },
        "description": {
          "type": "string",
          "required": false,
          "maxLength": 200,
          "description": "Optional description of what this sub-agent flow does"
        },
        "memory": {
          "type": "string",
          "required": false,
          "enum": ["user", "project", "local"],
          "description": "Persistent memory scope. 'user'=cross-project, 'project'=VCS-trackable, 'local'=local-only"
        },
        "outputPorts": {
          "type": "number",
          "required": true,
          "value": 1
        }
      },
      "inputPorts": 1,
      "outputPorts": 1,
      "mvpConstraints": {
        "noNesting": "SubAgentFlow nodes cannot be used inside sub-agent flows (no nesting allowed in Phase 1 MVP)",
        "noSubAgentInSubAgentFlow": "SubAgent nodes cannot be used inside sub-agent flows (Claude Code constraint)",
        "sequentialExecution": "Sub-agent flows execute sequentially from Start to End"
      },
      "aiGenerationGuidance": {
        "requirement": "When generating a subAgentFlow node, you MUST also create a corresponding SubAgentFlow definition in the 'subAgentFlows' array at the workflow root level",
        "subAgentFlowDefinition": {
          "id": "MUST match the subAgentFlowId in the reference node",
          "name": "Same as the label of the reference node",
          "description": "Optional description",
          "nodes": "MUST include at least Start and End nodes",
          "connections": "Connect Start to End (minimum structure)"
        },
        "constraints": [
          "SubAgentFlow nodes array can only contain: start, end, prompt, ifElse, switch, skill, mcp",
          "SubAgentFlow nodes array CANNOT contain: subAgent, subAgentFlow, askUserQuestion",
          "Maximum 30 nodes per SubAgentFlow"
        ],
        "example": {
          "nodeInWorkflow": {
            "id": "subflow-ref-1",
            "type": "subAgentFlow",
            "name": "validation-ref",
            "position": { "x": 400, "y": 200 },
            "data": {
              "subAgentFlowId": "validation-subflow-1",
              "label": "Input Validation",
              "description": "Validates user input",
              "outputPorts": 1
            }
          },
          "subAgentFlowDefinition": {
            "id": "validation-subflow-1",
            "name": "Input Validation",
            "description": "Validates user input",
            "nodes": [
              {
                "id": "sf-start",
                "type": "start",
                "name": "Start",
                "position": { "x": 100, "y": 300 },
                "data": { "label": "Start" }
              },
              {
                "id": "sf-end",
                "type": "end",
                "name": "End",
                "position": { "x": 400, "y": 300 },
                "data": { "label": "End" }
              }
            ],
            "connections": [
              {
                "id": "sf-conn-1",
                "from": "sf-start",
                "to": "sf-end",
                "fromPort": "output",
                "toPort": "input"
              }
            ]
          }
        }
      }
    },
    "codex": {
      "description": "Execute an OpenAI Codex CLI agent for code generation and analysis tasks. **Important: Phase 1 only supports UI/data model - CLI execution is not yet implemented.**",
      "fields": {
        "label": {
          "type": "string",
          "required": true,
          "minLength": 1,
          "maxLength": 64,
          "description": "Display label for the Codex agent"
        },
        "promptMode": {
          "type": "string",
          "required": true,
          "enum": ["fixed", "ai-generated"],
          "default": "fixed",
          "description": "Prompt mode: 'fixed' uses the prompt field as-is, 'ai-generated' lets the orchestrating AI agent generate instructions dynamically based on context"
        },
        "prompt": {
          "type": "string",
          "required": false,
          "maxLength": 10000,
          "description": "Instructions for the Codex agent. Required for 'fixed' mode, optional guidance for 'ai-generated' mode"
        },
        "model": {
          "type": "string",
          "required": true,
          "minLength": 1,
          "default": "gpt-5.2-codex",
          "description": "Model to use for Codex execution. Predefined options: gpt-5.2-codex, gpt-5.2, gpt-5.1-codex-max, gpt-5.1-codex-mini. Custom model names are also supported."
        },
        "reasoningEffort": {
          "type": "string",
          "required": true,
          "enum": ["low", "medium", "high"],
          "default": "medium",
          "description": "Reasoning effort level for the agent"
        },
        "sandbox": {
          "type": "string",
          "required": false,
          "enum": ["read-only", "workspace-write", "danger-full-access"],
          "description": "Optional. Sandbox mode for file system access. When specified, 'read-only' is recommended."
        },
        "outputPorts": {
          "type": "number",
          "required": true,
          "value": 1
        },
        "skipGitRepoCheck": {
          "type": "boolean",
          "required": false,
          "default": true,
          "description": "Skip Git repository trust check. When true, allows execution outside trusted Git repositories. Use with caution."
        }
      },
      "inputPorts": 1,
      "outputPorts": 1
    }
  },
  "connections": {
    "description": "Comprehensive specification for workflow connections. Defines connection object structure, port naming conventions, and completeness rules for AI-generated workflows.",
    "overview": {
      "description": "High-level connection constraints that apply to all workflows",
      "forbidden": [
        "Start node cannot have input connections",
        "End node cannot have output connections",
        "No cycles allowed",
        "No self-connections"
      ],
      "required": [
        "At least one connection per output port",
        "Exactly one Start node per workflow",
        "At least one End node per workflow",
        "All non-Start nodes must have input connection",
        "All non-End nodes must have output connection"
      ]
    },
    "format": {
      "description": "Connection object structure in connections array",
      "objectStructure": {
        "id": {
          "type": "string",
          "required": true,
          "example": "c1",
          "description": "Unique connection identifier. Must be unique across all connections in the workflow."
        },
        "from": {
          "type": "string",
          "required": true,
          "example": "start-1",
          "description": "Source node ID. Must reference an existing node in the nodes array."
        },
        "to": {
          "type": "string",
          "required": true,
          "example": "prompt-1",
          "description": "Target node ID. Must reference an existing node in the nodes array."
        },
        "fromPort": {
          "type": "string",
          "required": true,
          "description": "Source port identifier. See portNamingRules for complete mapping by node type. Examples: 'output', 'branch-0', 'branch-1'"
        },
        "toPort": {
          "type": "string",
          "required": true,
          "enum": ["input"],
          "description": "Target port is always 'input'. Every node has exactly one input port."
        },
        "condition": {
          "type": "string",
          "required": false,
          "example": "User selected Option A",
          "description": "Optional condition description for documenting branch semantics."
        }
      }
    },
    "portNamingRules": {
      "description": "Port identifier conventions for each node type. Linear nodes: single output. Conditional nodes: multiple outputs (one per branch).",
      "linearNodes": {
        "types": ["start", "end", "prompt", "subAgent", "skill", "mcp", "subAgentFlow", "codex"],
        "inputPortId": "input",
        "outputPortId": "output",
        "connectionExample": {
          "id": "c1",
          "from": "start-1",
          "to": "prompt-1",
          "fromPort": "output",
          "toPort": "input"
        }
      },
      "ifElseNode": {
        "type": "ifElse",
        "inputPortId": "input",
        "outputPortIds": ["branch-0", "branch-1"],
        "semantics": "branch-0 = true/if condition, branch-1 = false/else condition",
        "constraint": "BOTH branch-0 and branch-1 MUST each have exactly one outgoing connection",
        "connectionExample": {
          "id": "c2",
          "from": "ifelse-1",
          "to": "prompt-true",
          "fromPort": "branch-0",
          "toPort": "input"
        }
      },
      "switchNode": {
        "type": "switch",
        "inputPortId": "input",
        "outputPortIds": "branch-0, branch-1, ..., branch-N (where N = branchesLength - 1)",
        "constraint": "ALL branches (branch-0 through branch-N) MUST each have exactly one outgoing connection",
        "note": "Last branch is typically the 'default' case",
        "connectionExample": {
          "id": "c3",
          "from": "switch-1",
          "to": "handler-case-1",
          "fromPort": "branch-1",
          "toPort": "input"
        }
      },
      "askUserQuestionNode": {
        "type": "askUserQuestion",
        "inputPortId": "input",
        "outputPortIds": "DYNAMIC - depends on configuration",
        "modes": {
          "mode_aiSuggestions": {
            "condition": "useAiSuggestions: true",
            "outputPortId": "output",
            "description": "AI generates options at runtime. Single output port 'output' used."
          },
          "mode_multiSelect": {
            "condition": "multiSelect: true",
            "outputPortId": "output",
            "description": "Multi-select enabled. Single output port 'output' used."
          },
          "mode_singleSelect": {
            "condition": "useAiSuggestions: false AND multiSelect: false",
            "outputPortIds": "branch-0, branch-1, ..., branch-N (where N = optionsLength - 1)",
            "constraint": "ALL branches (branch-0 through branch-N) MUST each have exactly one outgoing connection",
            "description": "Single-select with user-defined options. One port per option."
          }
        },
        "connectionExample": {
          "id": "c4",
          "from": "ask-1",
          "to": "handler-option-a",
          "fromPort": "branch-0",
          "toPort": "input"
        }
      }
    },
    "completenessRules": {
      "description": "Completeness specification for workflow connections. Distinguishes between AI generation guidelines (what AI should produce) and export validation rules (what must be true at export/execution time). Manual canvas editing allows incomplete states - validation only occurs at export.",
      "aiGenerationRules": {
        "description": "Guidelines for AI-generated and AI-refined workflows. The AI system should ensure these rules are satisfied when generating/refining workflows. These guarantee that generated workflows are complete and ready to export.",
        "rules": [
          {
            "id": "START_OUTPUT",
            "rule": "Every Start node's 'output' port MUST have at least one outgoing connection",
            "aiGuidance": "When generating/adding a Start node, immediately create a connection from its 'output' port to the next node"
          },
          {
            "id": "NON_END_OUTPUT",
            "rule": "Every non-End node's output port(s) MUST have at least one outgoing connection per port",
            "example": "IfElse node with branch-0 and branch-1 requires both branches to be connected"
          },
          {
            "id": "NON_START_INPUT",
            "rule": "Every non-Start node's 'input' port MUST have exactly one incoming connection",
            "aiGuidance": "When creating or moving a node, ensure it receives an input connection from a predecessor"
          },
          {
            "id": "END_INPUT",
            "rule": "Every End node's 'input' port can have one OR MORE incoming connections (merge point allowed)",
            "example": "Multiple upstream paths can converge to a single End node"
          },
          {
            "id": "IFELSE_BOTH_BRANCHES",
            "rule": "IfElse node: BOTH branch-0 and branch-1 MUST have outgoing connections",
            "aiGuidance": "Create both connections before moving to next node"
          },
          {
            "id": "SWITCH_ALL_BRANCHES",
            "rule": "Switch node: ALL branch ports (branch-0 through branch-N) MUST have outgoing connections",
            "aiGuidance": "Count branches, create N connections (one per branch)"
          },
          {
            "id": "ASKUSERQUESTION_ALL_OPTIONS",
            "rule": "AskUserQuestion (single-select): ALL branch ports (branch-0 through branch-N) MUST have outgoing connections",
            "aiGuidance": "For single-select with N options, create N connections"
          },
          {
            "id": "NODE_ADDITION",
            "rule": "When adding a new node, immediately add an input connection to it (except Start)",
            "aiGuidance": "Never leave nodes disconnected. Node creation must be paired with connection creation."
          },
          {
            "id": "NODE_REMOVAL",
            "rule": "When removing a node, remove ALL connections associated with that node",
            "aiGuidance": "Before deleting a node, remove all edges where node is source or target"
          },
          {
            "id": "NODE_ID_VALIDITY",
            "rule": "Node IDs referenced in connections must exist in nodes array",
            "validation": "For each connection: verify 'from' node exists, verify 'to' node exists"
          }
        ]
      },
      "exportValidationRules": {
        "description": "Mandatory validation rules checked when exporting or executing a workflow. These rules apply to both manually-edited and AI-generated workflows. Workflows must pass these validations before execution.",
        "rules": [
          {
            "id": "EXACTLY_ONE_START",
            "rule": "Workflow MUST have exactly one Start node",
            "failureMessage": "Workflow must have exactly one Start node"
          },
          {
            "id": "AT_LEAST_ONE_END",
            "rule": "Workflow MUST have at least one End node",
            "failureMessage": "Workflow must have at least one End node"
          },
          {
            "id": "START_OUTPUT_CONNECTED",
            "rule": "Start node's 'output' port MUST be connected",
            "failureMessage": "Start node output must be connected to downstream node"
          },
          {
            "id": "END_INPUT_CONNECTED",
            "rule": "At least one End node's 'input' port MUST be connected",
            "failureMessage": "At least one End node must have incoming connection"
          },
          {
            "id": "ALL_NODES_REACHABLE",
            "rule": "All nodes MUST be reachable from Start node",
            "failureMessage": "Unreachable nodes found - ensure all nodes form a connected path from Start"
          },
          {
            "id": "ALL_PATHS_LEAD_TO_END",
            "rule": "All execution paths MUST lead to at least one End node",
            "failureMessage": "Dead-end paths found - ensure all branches converge to an End node"
          },
          {
            "id": "NO_CYCLES",
            "rule": "Workflow MUST NOT contain cycles",
            "failureMessage": "Circular reference detected - workflows must be acyclic (DAG)"
          },
          {
            "id": "NODE_ID_REFERENCES_VALID",
            "rule": "All node IDs in connections must reference existing nodes",
            "failureMessage": "Connection references non-existent node"
          },
          {
            "id": "CONDITIONAL_BRANCHES_CONNECTED",
            "rule": "All conditional node branches (IfElse, Switch, AskUserQuestion single-select) MUST have outgoing connections",
            "failureMessage": "Conditional node has disconnected branch"
          }
        ]
      },
      "postGenerationChecklist": {
        "description": "Quick checklist for verifying AI-generated workflows before returning to user",
        "items": [
          "✓ Exactly 1 Start node with output connected",
          "✓ At least 1 End node with input(s) connected",
          "✓ All non-Start nodes have input connected",
          "✓ All non-End nodes have output(s) connected",
          "✓ IfElse nodes: both branches connected",
          "✓ Switch nodes: all branches connected",
          "✓ AskUserQuestion nodes (single-select): all options connected",
          "✓ No dangling nodes",
          "✓ No circular references",
          "✓ All node IDs in connections exist in nodes array"
        ]
      }
    }
  },
  "validationRules": {
    "workflow": {
      "maxNodes": 50,
      "nameMaxLength": 100,
      "namePattern": "^[a-z0-9_-]+$",
      "versionPattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "node": {
      "nameMaxLength": 50,
      "namePattern": "^[a-zA-Z0-9_-]+$",
      "namePatternDescription": "IMPORTANT: Node names must use ASCII alphanumeric characters, hyphens, and underscores only. NO spaces or non-ASCII characters allowed."
    }
  },
  "subAgentFlowConstraints": {
    "description": "Constraints specific to Sub-Agent Flow editing. When refining a Sub-Agent Flow, these rules MUST be followed.",
    "maxNodes": 30,
    "supportedNodeTypes": ["start", "end", "prompt", "ifElse", "switch", "skill", "mcp", "codex"],
    "prohibitedNodeTypes": ["subAgent", "subAgentFlow", "askUserQuestion"],
    "rules": [
      "Sub-Agent Flows cannot contain SubAgent nodes (Claude Code constraint for sequential execution)",
      "Sub-Agent Flows cannot contain SubAgentFlow nodes (no nesting allowed in Phase 1 MVP)",
      "Sub-Agent Flows cannot contain AskUserQuestion nodes (user interaction not supported in sub-agent context)",
      "Sub-Agent Flows must have exactly one Start node and at least one End node",
      "Maximum 30 nodes per Sub-Agent Flow"
    ]
  },
  "workflowStructure": {
    "description": "Top-level workflow structure fields",
    "fields": {
      "id": { "type": "string", "required": true },
      "name": {
        "type": "string",
        "required": true,
        "maxLength": 100,
        "pattern": "^[a-z0-9_-]+$",
        "description": "Workflow name. Only lowercase letters (a-z), numbers, hyphens, and underscores allowed."
      },
      "description": { "type": "string", "required": false },
      "version": { "type": "string", "required": true, "pattern": "semver" },
      "nodes": {
        "type": "array",
        "required": true,
        "nodePositionGuidelines": {
          "description": "Each node must have a position: { x, y } in pixels. Follow these spacing rules for readable layouts.",
          "horizontalSpacing": 300,
          "verticalSpacing": 350,
          "rules": [
            "Place nodes left-to-right in execution order. Increment x by 300 for each step.",
            "For linear flows, keep all nodes at the same y value.",
            "For conditional branches (ifElse, switch, askUserQuestion), fan out vertically: center the parent, offset children by ±175 (2 branches) or ±350/0 (3 branches).",
            "After branches merge back, return to the parent's y value."
          ]
        }
      },
      "connections": {
        "type": "array",
        "required": true,
        "description": "Array of connections between workflow nodes. Each connection defines a directed edge from one node's output port to another node's input port. See 'connections' section for detailed specifications: format, portNamingRules, and completenessRules."
      },
      "subAgentFlows": {
        "type": "array",
        "required": false,
        "description": "Array of SubAgentFlow definitions. Each subAgentFlow node in 'nodes' MUST have a corresponding entry here with matching id.",
        "item": {
          "id": {
            "type": "string",
            "required": true,
            "description": "Unique ID matching subAgentFlowId in the reference node"
          },
          "name": { "type": "string", "required": true, "maxLength": 50 },
          "description": { "type": "string", "required": false, "maxLength": 200 },
          "nodes": {
            "type": "array",
            "required": true,
            "description": "Workflow nodes (must include Start and End)"
          },
          "connections": {
            "type": "array",
            "required": true,
            "description": "Connections between nodes"
          }
        }
      },
      "createdAt": { "type": "string", "required": true, "format": "ISO8601" },
      "updatedAt": { "type": "string", "required": true, "format": "ISO8601" }
    }
  },
  "examples": [
    {
      "name": "Simple Data Analysis",
      "complexity": "simple",
      "workflow": {
        "id": "ex-simple",
        "name": "data-analysis",
        "version": "1.0.0",
        "nodes": [
          {
            "id": "start-1",
            "type": "start",
            "name": "start-node",
            "position": { "x": 100, "y": 300 },
            "data": { "label": "Start" }
          },
          {
            "id": "agent-1",
            "type": "subAgent",
            "name": "analyzer",
            "position": { "x": 400, "y": 300 },
            "data": {
              "description": "Analyze data",
              "prompt": "Analyze data and generate insights.",
              "model": "sonnet",
              "outputPorts": 1
            }
          },
          {
            "id": "end-1",
            "type": "end",
            "name": "end-node",
            "position": { "x": 700, "y": 300 },
            "data": { "label": "End" }
          }
        ],
        "connections": [
          {
            "id": "c1",
            "from": "start-1",
            "to": "agent-1",
            "fromPort": "output",
            "toPort": "input"
          },
          { "id": "c2", "from": "agent-1", "to": "end-1", "fromPort": "output", "toPort": "input" }
        ],
        "createdAt": "2025-11-06T00:00:00Z",
        "updatedAt": "2025-11-06T00:00:00Z"
      }
    },
    {
      "name": "Code Review with Priority",
      "complexity": "medium",
      "workflow": {
        "id": "ex-medium",
        "name": "code-review",
        "version": "1.0.0",
        "nodes": [
          {
            "id": "start-1",
            "type": "start",
            "name": "start-node",
            "position": { "x": 100, "y": 300 },
            "data": { "label": "Start" }
          },
          {
            "id": "scanner-1",
            "type": "subAgent",
            "name": "scanner",
            "position": { "x": 400, "y": 300 },
            "data": {
              "description": "Scan code",
              "prompt": "Scan for bugs and issues.",
              "outputPorts": 1
            }
          },
          {
            "id": "ask-1",
            "type": "askUserQuestion",
            "name": "priority",
            "position": { "x": 700, "y": 300 },
            "data": {
              "questionText": "Priority level?",
              "options": [
                { "label": "Critical", "description": "High priority only" },
                { "label": "All", "description": "All issues" }
              ],
              "outputPorts": 2
            }
          },
          {
            "id": "fix-1",
            "type": "subAgent",
            "name": "critical-fixer",
            "position": { "x": 1000, "y": 125 },
            "data": {
              "description": "Critical fixes",
              "prompt": "Generate critical fixes.",
              "outputPorts": 1
            }
          },
          {
            "id": "fix-2",
            "type": "subAgent",
            "name": "all-fixer",
            "position": { "x": 1000, "y": 475 },
            "data": {
              "description": "All fixes",
              "prompt": "Generate all fixes.",
              "outputPorts": 1
            }
          },
          {
            "id": "end-1",
            "type": "end",
            "name": "end-node",
            "position": { "x": 1300, "y": 300 },
            "data": { "label": "End" }
          }
        ],
        "connections": [
          {
            "id": "c1",
            "from": "start-1",
            "to": "scanner-1",
            "fromPort": "output",
            "toPort": "input"
          },
          {
            "id": "c2",
            "from": "scanner-1",
            "to": "ask-1",
            "fromPort": "output",
            "toPort": "input"
          },
          { "id": "c3", "from": "ask-1", "to": "fix-1", "fromPort": "branch-0", "toPort": "input" },
          { "id": "c4", "from": "ask-1", "to": "fix-2", "fromPort": "branch-1", "toPort": "input" },
          { "id": "c5", "from": "fix-1", "to": "end-1", "fromPort": "output", "toPort": "input" },
          { "id": "c6", "from": "fix-2", "to": "end-1", "fromPort": "output", "toPort": "input" }
        ],
        "createdAt": "2025-11-06T00:00:00Z",
        "updatedAt": "2025-11-06T00:00:00Z"
      }
    },
    {
      "name": "Document Processing Pipeline",
      "complexity": "complex",
      "workflow": {
        "id": "ex-complex",
        "name": "doc-pipeline",
        "version": "1.0.0",
        "nodes": [
          {
            "id": "start-1",
            "type": "start",
            "name": "start-node",
            "position": { "x": 100, "y": 350 },
            "data": { "label": "Start" }
          },
          {
            "id": "validator-1",
            "type": "subAgent",
            "name": "validator",
            "position": { "x": 400, "y": 350 },
            "data": {
              "description": "Validate doc",
              "prompt": "Validate document format.",
              "outputPorts": 1
            }
          },
          {
            "id": "if-1",
            "type": "ifElse",
            "name": "valid-check",
            "position": { "x": 700, "y": 350 },
            "data": {
              "branches": [
                { "label": "Valid", "condition": "Passed" },
                { "label": "Invalid", "condition": "Failed" }
              ],
              "outputPorts": 2
            }
          },
          {
            "id": "analyzer-1",
            "type": "subAgent",
            "name": "analyzer",
            "position": { "x": 1000, "y": 175 },
            "data": {
              "description": "Analyze content",
              "prompt": "Analyze content.",
              "outputPorts": 1
            }
          },
          {
            "id": "error-1",
            "type": "subAgent",
            "name": "error-handler",
            "position": { "x": 1000, "y": 525 },
            "data": {
              "description": "Error report",
              "prompt": "Generate error report.",
              "outputPorts": 1
            }
          },
          {
            "id": "ask-1",
            "type": "askUserQuestion",
            "name": "format",
            "position": { "x": 1300, "y": 175 },
            "data": {
              "questionText": "Output format?",
              "options": [
                { "label": "PDF", "description": "PDF" },
                { "label": "Markdown", "description": "MD" },
                { "label": "HTML", "description": "HTML" }
              ],
              "outputPorts": 3
            }
          },
          {
            "id": "fmt-pdf",
            "type": "subAgent",
            "name": "pdf-fmt",
            "position": { "x": 1600, "y": -175 },
            "data": { "description": "PDF format", "prompt": "Format as PDF.", "outputPorts": 1 }
          },
          {
            "id": "fmt-md",
            "type": "subAgent",
            "name": "md-fmt",
            "position": { "x": 1600, "y": 175 },
            "data": {
              "description": "MD format",
              "prompt": "Format as Markdown.",
              "outputPorts": 1
            }
          },
          {
            "id": "fmt-html",
            "type": "subAgent",
            "name": "html-fmt",
            "position": { "x": 1600, "y": 525 },
            "data": { "description": "HTML format", "prompt": "Format as HTML.", "outputPorts": 1 }
          },
          {
            "id": "end-ok",
            "type": "end",
            "name": "success",
            "position": { "x": 1900, "y": 175 },
            "data": { "label": "Success" }
          },
          {
            "id": "end-err",
            "type": "end",
            "name": "error",
            "position": { "x": 1300, "y": 525 },
            "data": { "label": "Error" }
          }
        ],
        "connections": [
          {
            "id": "c1",
            "from": "start-1",
            "to": "validator-1",
            "fromPort": "output",
            "toPort": "input"
          },
          {
            "id": "c2",
            "from": "validator-1",
            "to": "if-1",
            "fromPort": "output",
            "toPort": "input"
          },
          {
            "id": "c3",
            "from": "if-1",
            "to": "analyzer-1",
            "fromPort": "branch-0",
            "toPort": "input"
          },
          {
            "id": "c4",
            "from": "if-1",
            "to": "error-1",
            "fromPort": "branch-1",
            "toPort": "input"
          },
          {
            "id": "c5",
            "from": "analyzer-1",
            "to": "ask-1",
            "fromPort": "output",
            "toPort": "input"
          },
          {
            "id": "c6",
            "from": "ask-1",
            "to": "fmt-pdf",
            "fromPort": "branch-0",
            "toPort": "input"
          },
          {
            "id": "c7",
            "from": "ask-1",
            "to": "fmt-md",
            "fromPort": "branch-1",
            "toPort": "input"
          },
          {
            "id": "c8",
            "from": "ask-1",
            "to": "fmt-html",
            "fromPort": "branch-2",
            "toPort": "input"
          },
          {
            "id": "c9",
            "from": "fmt-pdf",
            "to": "end-ok",
            "fromPort": "output",
            "toPort": "input"
          },
          {
            "id": "c10",
            "from": "fmt-md",
            "to": "end-ok",
            "fromPort": "output",
            "toPort": "input"
          },
          {
            "id": "c11",
            "from": "fmt-html",
            "to": "end-ok",
            "fromPort": "output",
            "toPort": "input"
          },
          {
            "id": "c12",
            "from": "error-1",
            "to": "end-err",
            "fromPort": "output",
            "toPort": "input"
          }
        ],
        "createdAt": "2025-11-06T00:00:00Z",
        "updatedAt": "2025-11-06T00:00:00Z"
      }
    }
  ]
}
